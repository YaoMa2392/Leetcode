两种二分查找解题方法：
1、二维矩阵，分两次二分查找，先找出target在哪一列，再在该列中找target
2、把二维矩阵当作一维矩阵来做
————————————————————————————————————————————————————————————————————————————————————————————————————

1、
由于二维矩阵固定列的「从上到下」或者固定行的「从左到右」都是升序的。因此我们可以使用两次二分来定位到目标位置：
第一次二分：从第 0 列中的「所有行」开始找，找到合适的行 row
第二次二分：从 row 中「所有列」开始找，找到合适的列 col

class Solution {
    public boolean searchMatrix(int[][] mat, int t) {
        int m = mat.length, n = mat[0].length;

        // 第一次二分：定位到所在行（从上往下，找到最后一个满足 mat[x]][0] <= t 的行号）
        int l = 0, r = m - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (mat[mid][0] <= t) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }

        int row = r;
        if (mat[row][0] == t) return true;
        if (mat[row][0] > t) return false;

        // 第二次二分：从所在行中定位到列（从左到右，找到最后一个满足 mat[row][x] <= t 的列号）
        l = 0; r = n - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (mat[row][mid] <= t) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        int col = r;

        return mat[row][col] == t;
    }
}

————————————————————————————————————————————————————————————————————————————————————————————————————

2、
当然，因为将二维矩阵的行尾和行首连接，也具有单调性。
我们可以将「二维矩阵」当做「一维矩阵」来做。
class Solution {
    public boolean searchMatrix(int[][] mat, int t) {
        int m = mat.length, n = mat[0].length;
        int l = 0, r = m * n - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (mat[mid / n][mid % n] <= t) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return mat[r / n][r % n] == t;
    }
}

___________________________________________________________________________________________________
//注意这里的中位数的求法 mid = l + r + 1 >> 1;
//注意if里面左指针 l = mid
//注意这边return的是右指针
