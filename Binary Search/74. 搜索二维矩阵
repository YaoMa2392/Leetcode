两种二分查找解题方法：
1、二维矩阵，分两次二分查找，先找出target在哪一列，再在该列中找target
2、把二维矩阵当作一维矩阵来做
————————————————————————————————————————————————————————————————————————————————————————————————————

1、
由于二维矩阵固定列的「从上到下」或者固定行的「从左到右」都是升序的。因此我们可以使用两次二分来定位到目标位置：
第一次二分：从第 0 列中的「所有行」开始找，找到合适的行 row
第二次二分：从 row 中「所有列」开始找，找到合适的列 col

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;  //列
        int n = matrix[0].length;  //行

        //第一次二分查找，找出target在哪一行
        int left = 0;
        int right = m - 1;
        while(left < right){
            int mid = left + right + 1 >> 1;
            if(target >=  matrix[mid][0]){
                left = mid;  //若target在该行，则target必然 >= 该行第一个数.所以这里left = mid不用+1
            }else{
                right = mid - 1;
            }
        }
        int row = right;  // target = (left, right], 所以这里是以右指针为准

        if(matrix[row][0] == target) return true;  //如果该行第一个数刚好是target，则直接true不用再找了
        if(matrix[row][0] > target) return false;  //如果所有行的第一个数（最大数）大于target，说明不存在，直接false
        //这两个判断可加可不加，加了优化判断；

        //第二次二分查找，在第一次找出的行中找到该target
        left = 0;
        right = n - 1;
        while(left < right){
            int mid = left + right + 1 >> 1;  //mid在循环体里面，所以需要重新int
            if(target >= matrix[row][mid]){
                left = mid;
            }else{
                right = mid - 1;
            }
        }
        int col = right;

        return matrix[row][col] == target;
    }
}
————————————————————————————————————————————————————————————————————————————————————————————————————

2、
当然，因为将二维矩阵的行尾和行首连接，也具有单调性。
我们可以将「二维矩阵」当做「一维矩阵」来做。
class Solution {
    public boolean searchMatrix(int[][] mat, int t) {
        int m = mat.length, n = mat[0].length;
        int left = 0, right = m * n - 1;  //当作一维矩阵的数组长度
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (mat[mid / n][mid % n] <= t) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return mat[r / n][r % n] == t;
    }
}

___________________________________________________________________________________________________
//注意这里的中位数的求法 mid = l + r + 1 >> 1;
1、mid = (left + right) / 2;  当 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug 得改！
2、mid = left + (right - left) / 2;  当 mid = left + (right - left) / 2 在 right 很大， left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。
3、最后，在 Java 的 JDK 的 Collections 和 Arrays 提供的 binarySearch 方法里看到了，中位数是这样取的：
   int mid = (low + high) >>> 1;
怎么又变成 + 了，一头雾水啊，会整型溢出吗？后来查了查资料，有可能会整型溢出的，不过结果依然正确。下面是原因：
left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。
首先解释“无符号右移”，在 Java 中，无符号右移运算符 >>> 和右移运算符 >> 的区别如下：
右移运算符 >> 在右移时，丢弃右边指定位数，左边补上符号位；
无符号右移运算符 >>> 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 >>> 后能变成正数。
了解了这一点，就能够理解 Java 中用 int mid = (low + high) >>> 1; 的原因了，关键不在 + ，而是“无符号右移”，在 Java 的 Collections 和 Arrays 提供的 binarySearch 方法里，low 和 high 都表示索引值，它们都是非负数，即使相加以后整型溢出，结果还是正确的，“位运算”本身就比其它运算符快，因此使用 + 和“无符号右移”可以说是既快又好的做法。

//注意if里面左指针 l = mid
若target在该行，则target必然 >= 该行第一个数.所以这里left = mid不用+1

//注意这边return的是右指针
target = (left, right]
