两种二分查找解题方法：
1、二维矩阵，分两次二分查找，先找出target在哪一列，再在该列中找target
2、把二维矩阵当作一维矩阵来做
————————————————————————————————————————————————————————————————————————————————————————————————————

1、
由于二维矩阵固定列的「从上到下」或者固定行的「从左到右」都是升序的。因此我们可以使用两次二分来定位到目标位置：
第一次二分：从第 0 列中的「所有行」开始找，找到合适的行 row
第二次二分：从 row 中「所有列」开始找，找到合适的列 col

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;  //列
        int n = matrix[0].length;  //行

        //第一次二分查找，找出target在哪一行
        int left = 0;
        int right = m - 1;
        while(left < right){
            int mid = left + right + 1 >> 1;
            if(target >=  matrix[mid][0]){
                left = mid;  //若target在该行，则target必然 >= 该行第一个数.所以这里left = mid不用+1
            }else{
                right = mid - 1;
            }
        }
        int row = right;  // target = (left, right], 所以这里是以右指针为准

        if(matrix[row][0] == target) return true;  //如果该行第一个数刚好是target，则直接true不用再找了
        if(matrix[row][0] > target) return false;  //如果所有行的第一个数（最大数）大于target，说明不存在，直接false
        //这两个判断可加可不加，加了优化判断；

        //第二次二分查找，在第一次找出的行中找到该target
        left = 0;
        right = n - 1;
        while(left < right){
            int mid = left + right + 1 >> 1;  //mid在循环体里面，所以需要重新int
            if(target >= matrix[row][mid]){
                left = mid;
            }else{
                right = mid - 1;
            }
        }
        int col = right;

        return matrix[row][col] == target;
    }
}
————————————————————————————————————————————————————————————————————————————————————————————————————

2、
当然，因为将二维矩阵的行尾和行首连接，也具有单调性。
我们可以将「二维矩阵」当做「一维矩阵」来做。
class Solution {
    public boolean searchMatrix(int[][] mat, int t) {
        int m = mat.length, n = mat[0].length;
        int left = 0, right = m * n - 1;  //当作一维矩阵的数组长度
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (mat[mid / n][mid % n] <= t) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return mat[r / n][r % n] == t;
    }
}

___________________________________________________________________________________________________
//注意这里的中位数的求法 mid = l + r + 1 >> 1;
//注意if里面左指针 l = mid
//注意这边return的是右指针
