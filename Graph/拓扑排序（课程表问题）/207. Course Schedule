class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // 1. 用 HashMap 来保存节点的入度
        Map<Integer, Integer> inDegree = new HashMap<>();
        // 先将所有的课程放入 HashMap中
        for(int i = 0; i < numCourses; i++){
            inDegree.put(i, 0);
        }
        
        // 2. 用 HashMap 来保存依赖关系。依赖关系，依赖当前课程的后续课程。
        Map<Integer, List<Integer>> adj = new HashMap<>();
        
        // 初始化入度和依赖关系
        for(int[] pre : prerequisites){
            // (3,0), 想学3号课程要先完成0号课程, 更新3号课程的入度和0号课程的依赖(邻接表)
            int cur = pre[1];
            int next = pre[0];
            // 更新入度
            inDegree.put(next, inDegree.get(next) + 1);
            // 当前节点的邻接表
            if(!adj.containsKey(cur)){
                adj.put(cur, new ArrayList<>());
            }
            adj.get(cur).add(next);
        }
        
        // 3. BFS, 将入度为 0 的课程放入队列，队列中的课程就是没有先修，可以学的课程
        Queue<Integer> que = new LinkedList<>();
        for(int key : inDegree.keySet()){
            if(inDegree.get(key) == 0){
                que.offer(key);
            }
        }
        
        // 取出一个节点，对应学习这门课程
        // 遍历当前邻接表，更新其入度；
        // 更新之后查看inDegree，如果为0，加入到队列
        while(!que.isEmpty()){
            int cur = que.poll();
            // 遍历当前课程表的邻接表，更新后继节点的入度
            if(!adj.containsKey(cur)){
                continue;
            }
            List<Integer> successorList = adj.get(cur);
            
            for(int key : successorList){
                inDegree.put(key, inDegree.get(key) - 1);
                if(inDegree.get(key) == 0){
                    que.offer(key);
                }
            }
        }
        
        // 4. 遍历入队，如果还有课程的入度不为 0，返回 false
        for(int key : inDegree.keySet()){
            if(inDegree.get(key) != 0){
                return false;
            }
        }
        return true;
    }
}
