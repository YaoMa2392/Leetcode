1. 冒泡排序（超时）
class Solution {
    public int[] sortArray(int[] nums) {
        if(nums.length < 2){
            return nums;
        }
        
        // n - 1 轮次执行，当前n - 1 个元素排好后，最后一个元素无需执行，故 i < nums.length - 1
        for(int i = 0; i < nums.length - 1; i++){
            // 本轮执行是否有过交换，有则true，无则false
            boolean swapped = false;
            // 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右
            for(int j = 1; j < nums.length - i; j++){
                // 若左 > 右，交换，并将swapped设置为true
                if(nums[j - 1] > nums[j]){
                    int temp = nums[j - 1];
                    nums[j - 1] = nums[j];
                    nums[j] = temp;
                    swapped = true;
                }
            }
            // 若无交换，则表示当前数组已经完成排序，退出大循环
            if(!swapped){
                break;
            }
        }
        return nums;
    }
}
--------------------------------------------------------------------
2. 选择排序（超时）
--------------------------------------------------------------------
3. 插入排序（慢）
class Solution {
    public int[] sortArray(int[] nums) {
        if(nums.length < 2){
            return nums;
        }
        for(int i = 1; i < nums.length; i++){
            int target = nums[i];
            int j = i - 1;
            for(; j >= 0; j--){
                if(target < nums[j]){
                    nums[j + 1] = nums[j];
                }else{
                    break;
                }
            }
            nums[j + 1] = target; 
        }
        return nums;
    }
}
