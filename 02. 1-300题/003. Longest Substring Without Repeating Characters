1. 滑动窗口

思路及算法：

===============================================

我们先用一个例子考虑如何在较优的时间复杂度内通过本题。

我们不妨以示例一中的字符串 abcabcbb 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：

    以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
    以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
    以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
    以 abc(a)bcbb 开始的最长字符串为 \texttt{abc(abc)bb}abc(abc)bb；
    以 abca(b)cbb 开始的最长字符串为 \texttt{abca(bc)bb}abca(bc)bb；
    以 abcab(c)bb 开始的最长字符串为 \texttt{abcab(cb)b}abcab(cb)b；
    以 abcabc(b)b 开始的最长字符串为 \texttt{abcabc(b)b}abcabc(b)b；
    以 abcabcb(b) 开始的最长字符串为 \texttt{abcabcb(b)}abcabcb(b)。
    
发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 r_k 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 r_k 的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 r_k ，直到右侧出现了重复字符为止。

===============================================

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

  我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 r_k；
  在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；
  在枚举结束后，我们找到的最长的子串的长度即为答案。
  
===============================================

判断重复字符

在上面的流程中，我们还需要使用一种数据结构来判断“是否有重复的字符”，常用的数据结构为哈希集合（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

至此，我们就完美解决了本题。

===============================================

代码：
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int res = 0;
        // Hash Set，记录每个字符是否出现过
        Set<Character> occ = new HashSet<Character>();
        // 右指针，初始值为 -1 ，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1;
        for(int i = 0; i < s.length(); ++i){
            // 当不符合下述情况，且 i ！= 0时，左指针右移，移除左边的字符
            if(i != 0){
                occ.remove(s.charAt(i - 1));
            }
            // 当 rk + 1的值不超过范围，且HashSet中没有时，将其加入HashSet
            while(rk + 1 < s.length() && !occ.contains(s.charAt(rk + 1))){
                occ.add(s.charAt(rk + 1));
                ++rk;
            }
            // 获取result
            res = Math.max(res, rk - i + 1);
        }
        return res;
    }
}

复杂度分析:
时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。
空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符），|\Sigma|∣Σ∣ 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 ∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。


-------------------------------------------------------------------------

知识点：
   *注意点：String的长度要加括号：
      int s; s.length;
      String s; s.length();
      
    charAt:
      charAt(int index)方法是一个能够用来检索特定索引下的字符的String实例的方法。charAt()方法返回指定索引位置的char值。
      语法：public char charAt(int index)
      实例：
        public class Test {
          public static void main(String args[]) {
            String s = "www.runoob.com";
            char result = s.charAt(6);
            System.out.println(result);
          }
        }
      运行结果：n
      
    HashSet:
    HashSet是set接口的实现类，也是我们最常用的set集合。
    储存的是无序，唯一的对象。遍历可能是有序，可能是无序的。
    由于是无序的所以每组数据都没有索引，很多list可用的方法它都没有。
    凡是需要通过索引来进行操作的方法都没有，所以也不能使用普通for循环来进行遍历，只有加强型for和迭代器两种遍历方法。
    *HashSet的元素不能重复
    *HashSet中允许有NULL值
    
    操作：
      1. 创建HashSet：
          Set<Character> occ = new HashSet<Character>();
      2. check HashSet 中是否包含某个值（x）：
          occ.contains(x);
      3. 向HashSet添加元素（x）：
          occ.add(x);
      4. 从HashSet删除元素（x）：
          occ.remove(x);
          
       
      
