方法一：深度优先搜索
思路

按深度优先搜索的顺序计算范围和。记当前子树根节点为 root，分以下四种情况讨论：

1. root 节点为空
   返回 0。
   
2. root 节点的值大于 high
   由于二叉搜索树右子树上所有节点的值均大于根节点的值，即均大于 high，故无需考虑右子树，返回左子树的范围和。

3. root 节点的值小于 low
由于二叉搜索树左子树上所有节点的值均小于根节点的值，即均小于 low，故无需考虑左子树，返回右子树的范围和。

4. root 节点的值在 [low,high] 范围内
此时应返回 \textit{root}root 节点的值、左子树的范围和、右子树的范围和这三者之和。

=====================================================================

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null){
            return 0;
        }
        if(root.val > high){
            return rangeSumBST(root.left, low, high);
        }
        if(root.val < low){
            return rangeSumBST(root.right, low, high);
        }
        return root.val + rangeSumBST(root.left, low, high) + rangeSumBST(root.right, low, high);
    }
}

// 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。
// 空间复杂度：O(n)。空间复杂度主要取决于栈空间的开销。
